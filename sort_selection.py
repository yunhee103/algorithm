# 선택정렬: 주어진 데이터 리스트에서 가장 작은 원소를 선택하여 맨 앞으로 보내는 방식
# 시간 복잡도(O(n^2)): 이중 반복문을 사용하여 모든 원소를 비교하기 때문에 입력 크기에 비례하여 실행 시간이 증가한다.
# 알고리즘 과정:
# 1. 최소값 찾기: 주어진 리스트에서 가장 작은 원소를 찾는다.
# 2. 교환: 찾은 원소를 리스트의 맨 앞에 위치한 원소와 교환한다.
# 3. 반복: 맨 앞의 원소를 제외한 나머지 리스트에 대해 1번과 2번 과정을 반복한다.

# 선택 정렬(selection sort)은 주어진 데이터 리스트에서 가장 작은 원소를 선택하여 맨 앞으로 이동시키는 작업을 반복하는 정렬 알고리즘입니다.
# 알고리즘 과정:
# 최소값 찾기: 정렬되지 않은 부분에서 가장 작은 값을 찾습니다.
# 교환: 찾은 최소값을 정려되지 않은 부분의 맨 앞으로 이동시킴
# 반복: 정렬되지 않은 부분의 크기가 1이 될때까지 위 과정을 반복함

# 방법1: 원리 이해를 우선
def find_min_func(a):
    n = len(a)
    min_index = 0
    for i in range(1, n):
        if a[i] < a[min_index]: # 현재 최소값보다 작은 값이 있으면
            min_index = i # 최소값의 인덱스를 갱신
    return min_index

# 이 코드는 메모리를 너무 써서 답안용으로는 부적절


def sel_sort(a):
    result = []
    while a:  # 리스트가 비어있지 않을 때까지 반복
        min_index = find_min_func(a)  # 최소값의 인덱스 찾기
        value = a.pop(min_index)  # 최소값을 리스트에서 제거
        result.append(value)  # 최소값을 결과 리스트에 추가
    return result

d = [2, 4, 5, 1, 3]
print('선택 정렬 방법1:', sel_sort(d))

# 방법2: 일반적 정렬 알고리즘을 구사
# 각 반복마다 가장 작은 값을 해당 집합내의 맨 앞자리와 값을 바꿈

# 방법2: 일반적 정렬 알고리즘을 구사(메모리 절감도 함?) : result x 안써요안써

def sel_sort2(a):
    n = len(a)
    for i in range(0, n - 1):  # 리스트의 모든 원소에 대해 반복
        min_index = i # 현재 원소의 인덱스를 최소값 인덱스로 설정
        # i 다음 원소부터 끝까지 반복하여 최소값 찾기
        for j in range(i + 1, n): # i 다음 원소부터 끝까지 반복
            if a[j] < a[min_index]: # 현재 최소값보다 작은 값이 있으면
                min_index = j # 최소값의 인덱스를 갱신
        a[i], a[min_index] = a[min_index], a[i] # 최소값과 현재 원소를 교환
    return a

d = [2, 4, 5, 1, 3]
print('선택 정렬 방법2:', sel_sort2(d))